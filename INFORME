ALGORITMOS PRACTICA 3

Ali Abu-afash Nayef
Martín Rodríguez Arévalo
Alejandro Patiño Jaramillo

Buscamos ordenar de menor a mayor un vector de n números enteros implementendo
el algoritmo de ordenación rápida y a su vez determinar los tiempos de ejecución 
dependiendo de como esté inicializado el vector y del umbral que se esté utilizando.

El vector se inicializa desordenado, ordenado de menor a mayor y de mayor a menor.
Después para cada inicialización se emplean primero el umbral 1 y después el umbral 
10 y 100.

Las tablas presentan al menos cinco valores de progresión geométrica de 2^,
sus respectivos tiempos de ejecución en microsegundos con sus respectivas cotas con 
al menos tres cifras significativas.

Para este algoritmo se contrastan los tiempos con una cota subestimada, ajustada y 
sobrestimada.

Cuando se detecta una medición inferior a la confianza establecida, en este caso de 
500 microsegundos, se resalta con el simbolo (*) y se obtiene ese tiempo mediante 
una media de 1000 ejecuciones de un bucle. Por otro lado, se han tradato de impedir y 
documentar las mediciones anómalas.

Los algoritmos fueron ejecutados en un portátil con las siguientes especificaciones:
    Kernel: x86_64 6.14.0-29-generic #29~24.04.1-Ubuntu
    CPU: AMD Ryzen 7 7735HS @ 16x 8
    GPU: NVIDIA GeForce RTX 4060 Laptop GPU
    RAM: 15592 MB















Tras observar los resultados obtenidos se puede afirmar que a medida que aumenta el umbral
los tiempos de ejecución disminuyen. 
En el caso de cuando el vector está inicializado desordenado se observa que el umbral 10 
obtiene mejores tiempos de ejecución y el umbral 100 en un poco, pero tampoco mucho, más 
eficaz que el umbral 1 para esta inicialización.
Cuando el vector está ordenado previamente de menor a mayor se obtienen tiempos de ejecución
menores a medida que el umbral aumenta.
Y en el último caso, cuando está inicializado de mayor a menor ocurre lo mismo que cuando está
ordenado de menor a mayor, a medida que aumenta el umbral disminuyen los tiempos de ejecución.